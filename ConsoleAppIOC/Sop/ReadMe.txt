定义：控制反转是一种设计原则，它反转了传统编程中的控制流程。在传统的编程模式中，组件之间的依赖关系是由组件自身在内部创建和维护的。
而在控制反转模式中，这种依赖关系由外部容器（如Spring框架、.NET中的Microsoft.Extensions.DependencyInjection等）来管理，
组件不再负责自己的依赖，而是通过外部容器来注入所需的依赖。

核心思想：将对象的创建和它们之间的依赖关系管理从对象本身转移到外部容器。

优点：

降低耦合度：组件之间的依赖关系不再是硬编码的，因此可以更容易地更换组件实现，提高系统的灵活性和可维护性。
提高模块化：各个组件可以独立开发和测试，因为它们不依赖于具体的实现，而是依赖于抽象的接口或抽象类。
便于测试：由于组件之间的依赖被外部化，可以更容易地使用mock对象或测试桩来模拟依赖进行单元测试。
---------------------------------------------------------------------------------------------------------------------------

依赖注入（Dependency Injection, DI）
定义：依赖注入是实现控制反转的一种具体方式。它涉及将依赖关系（服务或对象）传递到类中，而不是让类自己创建它们。

实现方式：

构造函数注入：通过类的构造函数提供依赖关系。这是C#中最常见和推荐的DI形式。
属性注入：通过类的公共属性分配依赖关系。这种方法提供了灵活性，但可能暴露内部状态，减少封装性。
方法注入：通过方法参数传递依赖关系。适用于仅对特定方法需要的依赖关系进行注入。
-------------------------------------------------------------------------------------------------------------------------

IOC容器
定义：IOC容器是一个用于管理对象生命周期和依赖关系的框架。它根据配置（如XML文件、注解或代码配置）自动创建对象，
并将依赖关系注入到这些对象中。

作用：

对象创建：根据配置自动创建对象实例。
依赖注入：将依赖关系注入到对象中，实现控制反转。
生命周期管理：管理对象的生命周期，包括创建、销毁和回收资源。
-------------------------------------------------------------------------------------------------------------------------

一、服务生命周期详解
在DI中，服务的生命周期管理至关重要，因为它决定了服务的实例如何被创建和共享。Microsoft.Extensions.DependencyInjection支持以下三种主要的服务生命周期：

Transient（瞬时）：每次从容器中请求服务时，都会创建一个新的实例。适用于轻量级、无状态的服务。
Scoped（作用域）：在同一个作用域（如HTTP请求）内，服务只会被创建一次实例，并在该作用域结束时销毁。适用于与请求相关的服务，如数据库上下文。
Singleton（单例）：整个应用程序生命周期内只创建一个实例，并在应用程序结束时销毁。适用于全局状态或配置信息。
-------------------------------------------------------------------------------------------------------------------------

二、注册服务
服务注册通常在应用程序的启动阶段进行，通过IServiceCollection接口的方法实现。这些注册方法会根据服务的生命周期将服务添加到DI容器中。
public void ConfigureServices(IServiceCollection services)
{
    // 注册瞬时服务
    services.AddTransient<ITransientService, TransientService>();
    
    // 注册作用域服务
    services.AddScoped<IScopedService, ScopedService>();
    
    // 注册单例服务
    services.AddSingleton<ISingletonService, SingletonService>();
    
    // 也可以注册第三方库的服务
    services.AddDbContext<MyDbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
}
-------------------------------------------------------------------------------------------------------------------------

三、注入依赖关系
依赖注入通常通过构造函数进行。当IOC容器创建类的实例时，它会自动查找并注入构造函数中声明的依赖项。
1.依赖注入具有“传染性”，如果一个类的对象是通过DI（容器）创建的，那么这个类的构造函数中声明的所有服务类型的参数都会被DI赋值；
但如果一个对象是程序员手动创建的（new），那么这个对象就和DI没有关系，它的构造函数中声明的服务类型参数就不会被自动赋值。
2..NET的DI默认注入是构造函数注入；
public class MyController : Controller
{
    private readonly IMyService _myService;

    // 通过构造函数注入依赖
    public MyController(IMyService myService)
    {
        _myService = myService;
    }

    public IActionResult Index()
    {
        // 使用注入的服务
        var result = _myService.GetData();
        // ...
        return View(result);
    }
}
-------------------------------------------------------------------------------------------------------------------------

四、注意事项与最佳实践
使用基于接口的抽象：总是通过接口或抽象类来定义服务，而不是直接使用具体类。这样做可以增加代码的灵活性和可测试性。

避免过度使用单例：单例服务在整个应用程序生命周期内只有一个实例，这可能导致状态管理变得复杂和难以预测。应谨慎使用，并确保单例服务是线程安全的。

避免循环依赖：循环依赖是DI容器难以解决的常见问题之一。它发生在两个或多个服务相互依赖对方时。应通过重新设计服务结构来避免循环依赖。

利用选项模式：对于需要配置的服务，.NET Core提供了选项模式（Options Pattern），允许将配置数据绑定到强类型对象上，并通过DI自动注入这些对象。

单元测试：利用DI和Mocking框架（如Moq）进行单元测试，可以轻松地模拟依赖项，并专注于测试目标类的逻辑。

了解服务作用域：确保了解不同作用域下的服务行为，特别是作用域服务和单例服务之间的区别。作用域服务在请求结束时会被销毁，而单例服务则在整个应用程序生命周期内存在。
